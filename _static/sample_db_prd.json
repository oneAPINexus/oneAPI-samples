[{"name":"1D Heat Transfer","description":"The 1D Heat Transfer sample simulates 1D Heat\nTransfer problem using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/1d_HeatTransfer","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"AC Fixed","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe Algorithmic C Fixed Point Data Type (AC Fixed)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/ac_fixed","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"AC Int","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe Algorithmic C Integer (AC Int)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/ac_int","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Adaptive Noise Reduction","description":"A highly optimized adaptive noise reduction (ANR)\nalgorithm on an FPGA.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/anr","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"alignedTypes","description":"This sample demonstrates the access speed gap of\naligned & misaligned types","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_alignedTypes_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"All Pairs Shortest Paths","description":"All Pairs Shortest Paths finds the shortest paths\nbetween pairs of vertices in a graph using a\nparallel blocked algorithm that enables the\napplication to efficiently offload compute...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphAlgorithms\/all-pairs-shortest-paths","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"american_options","description":"American Options Pricing is a model that is based\non the Monte Carlo method and widely used in\nfinancial services industry. The original CUDA*\nsource code is migrated to SYCL for portability...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_american_options_SYCLmigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Annotated Classes Clean Coding","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nannotated_class_util.hpp to simplify your oneAPI\ncode that annotates properties to pipes and\nannotated_arg","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/annotated_class_clean_coding","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"annotated_ptr","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nannotated_ptr to constrain the global memory\naccesses inside a kernel","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/annotated_ptr","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Autorun kernels","description":"Intel\u00ae FPGA tutorial demonstrating autorun kernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/autorun","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Avalon Memory-Mapped Host Interfaces","description":"An Intel\u00ae FPGA tutorial demonstrating how to\nannotate pointer arguments to customize Avalon\nmemory-mapped host interfaces","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/hls_flow_interfaces\/mmhost","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Base: Vector Add","description":"This simple sample adds two large vectors in\nparallel. Provides a \u2018Hello World!\u2019 like sample to\nensure your environment is setup correctly using\nsimple C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/vector-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU","FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Batched Linear Solver","description":"Solve batched linear systems using oneMKL and\nOpenMP target offloading","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/batched_linear_solver","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Binomial","description":"Binomial European Option Pricing Model Simulation\nusing Intel\u00ae oneMKL Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/binomial","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Bitonic Sort","description":"Bitonic Sort using C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/bitonic-sort","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Black Scholes","description":"Black Scholes formula calculation using Intel\u00ae\noneMKL Vector Math and Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/black_scholes","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Block Cholesky Decomposition","description":"Block Cholesky Decomposition using Intel\u00ae oneMKL\nBLAS and LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_cholesky_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Block LU Decomposition","description":"Block LU Decomposition using Intel\u00ae oneMKL BLAS\nand LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_lu_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Board Test","description":"An Intel\u00ae FPGA test to check board interfaces and\nsome of the oneAPI shim\/BSP metrics like memory\nbandwidth, kernel clock frequency and kernel\nlatency","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/board_test","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Buffered Host-Device Streaming","description":"An FPGA tutorial demonstrating how to stream data\nbetween the host and device with multiple buffers","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/buffered_host_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Census","description":"This sample illustrates the use of Intel\u00ae\nDistribution of Modin* and Intel Extension for\nScikit-learn to build and run an end-to-end\nmachine learning workload","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/Census","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Cholesky decomposition","description":"Reference design demonstrating high-performance\nCholesky decomposition of real and complex\nmatrices on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/cholesky","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Cholesky-based matrix inversion","description":"Reference design demonstrating high-performance\nCholesky-based inversion of real and complex\nmatrices on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/cholesky_inversion","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Coarray Fortran","description":"Demonstrates how to build and run a serial\nimplementation of a Monte Carlo program, and then\nconvert it to run in parallel using Fortran\ncoarrays.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_Coarray","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Complex Mult","description":"This sample computes Complex Number Multiplication","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/complex_mult","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Component Interfaces Comparison","description":"Intel\u00ae FPGA tutorial introducing different\ninvocation\/data interfaces that can be used for IP\ncomponents","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/hls_flow_interfaces\/component_interfaces_comparison","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Compute Units","description":"Intel\u00ae FPGA tutorial showcasing a design pattern\nto enable the creation of compute units","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/compute_units","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Computed Tomography","description":"Reconstruct an image from simulated CT data with\nIntel\u00ae oneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/computed_tomography","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"convolutionSeparable","description":"This sample implements a separable convolution\nfilter of a 2D signal with a gaussian kernel.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_convolutionSeparable_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"CRR Binomial Tree","description":"This sample shows a Binomial Tree Model for Option\nPricing using a FPGA-optimized reference design of\nthe Cox-Ross-Rubinstein (CRR) Binomial Tree Model\nwith Greeks for American exercise options","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/crr","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"cuBLAS Migration","description":"This sample shows the execution of cuBLAS function\nmigrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuBLAS_examples_SYCL_Migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"CUDA to SYCL Migration","description":"CUDA_To_SYCL_Migration Tutorials using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/cuda-to-sycl-migration-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"cuRAND Migration","description":"This sample shows the execution of cuRAND function\nmigrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuRAND_examples_SYCL_migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"DB","description":"An FPGA reference design that demonstrates high-\nperformance Database Query Acceleration on Intel\u00ae\nFPGAs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/db","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Debugger: Array Transform","description":"A small SYCL (C++)  example that is used in the\n\"Get Started Guide\" of the Application Debugger to\nexercise major debugger functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/array-transform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Decompression","description":"Optimized implementations of GZIP and SNAPPY\ndecompression on an FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/decompress","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Device Global","description":"An Intel\u00ae FPGA tutorial demonstrating the\ndevice_global feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/device_global","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Discrete Cosine Transform","description":"An image processing algorithm as seen in the JPEG\ncompression standard","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SpectralMethods\/DiscreteCosineTransform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Distributed Jacobian Solver SYCL\/MPI","description":"Distributed implementation of Jacobian solver with\nOpenMP\/SYCL offload and MPI-3 one-sided.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/MPI\/jacobian_solver","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Double Buffering","description":"Intel\u00ae FPGA tutorial design to demonstrate\noverlapping kernel execution with buffer transfers\nand host-processing to improve system performance","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/double_buffering","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"DPC Reduce","description":"This sample models transform Reduce in different\nways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/dpc_reduce","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"DSP Control","description":"An Intel\u00ae FPGA tutorial demonstrating the DSP\ncontrol feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/dsp_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"dwtHaar1D Sample","description":"This sample computes Discrete Haar wavelet\ndecomposition for 1D signals with a length which\nis a power of 2.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_dwtHaar1D_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"dwtHaar1D Sample","description":"This sample computes Discrete Haar wavelet\ndecomposition for 1D signals with a length which\nis a power of 2.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_dwtHaar1D_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Dynamic Profiler","description":"An tutorial demonstrating how to use the Intel\u00ae\nFPGA Dynamic Profiler for Data Parallel C++\n(DPC++) to dynamically collect performance data\nand reveal areas for optimization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/dynamic_profiler","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Edge Detection in Simple Binary Images","description":"Offload Fortran loops to a GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/EdgeDetection\/simple-binary-images","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"EigenValues Sample","description":"This sample demonstrates a parallel implementation\nof a bisection algorithm for the computation of\nall eigenvalues of a tridiagonal symmetric matrix\nof arbitrary size.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_eigenValues_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Enable Auto-Mixed Precision for Transfer Learning with TensorFlow","description":"This tutorial guides you through the process of\nenabling auto-mixed precision to use low-precision\ndatatypes, like bfloat16, for transfer learning\nwith TensorFlow*","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Enabling_Auto_Mixed_Precision_for_TransferLearning","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Explicit Data Movement","description":"An Intel\u00ae FPGA tutorial demonstrating an\nalternative coding style, explicit USM, in which\nall data movement is controlled explicitly by the\nauthor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/explicit_data_movement","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Fast Recompile","description":"An Intel\u00ae FPGA tutorial demonstrating how to\nseparate the compilation of host and device code\nto save development time","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fast_recompile","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"fastWalshTransform","description":"This sample demonstrates the efficient\nimplementation of naturally-ordered Walsh\ntransform","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_fastWalshTransform_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"fastWalshTransform","description":"This sample demonstrates the efficient\nimplementation of naturally-ordered Walsh\ntransform","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_fastWalshTransform_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Fine-tuning Text Classification Model with Intel\u00ae Neural Compressor (INC)","description":"This sample demonstrates how to fine-tune text\nmodel for emotion classification task using Intel\u00ae\nNeural Compressor Quantization Aware Training\n(QAT).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/INC_QuantizationAwareTraining_TextClassification","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Folder Options DPCT","description":"Multi-folder project that illustrates migration of\na CUDA project that has files located in multiple\nfolders in a directory tree. Uses the `--in-root`\nand `--out-root` options to tell the Intel\u00ae...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/folder-options-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Fourier Correlation","description":"Compute Fourier correlation with oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/fourier_correlation","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"FPGA Compile","description":"Intel\u00ae FPGA tutorial introducing how to use SYCL\nto target FPGAs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fpga_compile","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"FPGA Reg","description":"An Intel\u00ae FPGA advanced tutorial demonstrating how\nto apply the SYCL extension ext::intel::fpga_reg","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/fpga_reg","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"FPGA Template","description":"An Intel\u00ae FPGA tutorial that explains the CMake\nbuild system that is used in other code samples,\nand serves as a template that you can re-use in\nyour own designs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/GettingStarted\/fpga_template","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Game of Life","description":"The visualization of Conway's Game of Life","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/VisualizedSamples\/GameOfLife","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Gamma Correction","description":"Gamma Correction - a nonlinear operation used to\nencode and decode the luminance of each image\npixel","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/gamma-correction","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Genetic Algorithms on GPU using Intel\u00ae Distribution of Python numba-dpex","description":"This sample shows how to implement general genetic\nalgorithm (GA) and offload computation to GPU\nusing numba-dpex.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_GPU_numba-dpex_Genetic_Algorithm","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Getting Started","description":"Basic Intel\u00ae oneDNN programming model for both\nIntel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDNN\/getting_started","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Getting Started with Intel\u00ae Neural Compressor for Quantization","description":"This sample is a getting started guide for Intel\u00ae\nNeural Compressor to do INT8 quantization on a\nHuggingface BERT model. This allows us to achieve\nperformance boosts on Intel hardware.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Quantization-Sample-for-PyTorch","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Guided iso3dfd GPU optimization","description":"Step-by-step GPU optimization guide with Intel\nAdvisor and ISO3DFD sample","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_iso3dfd_GPUOptimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Guided iso3dfd GPU optimization","description":"Step-by-step GPU optimization guide with Intel\nAdvisor and ISO3DFD sample","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_iso3dfd_GPUOptimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Guided Matrix Multiplication Bad Buffers","description":"The Guided Matrix Multiplication Bad Buffers\nsample demonstrates how to use the Intel\u00ae oneAPI\nBase Toolkit (Base Kit) and several tools found in\nit to triage incorrect use of the SYCL language.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_BadBuffers","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Guided Matrix Multiplication Illegal SLM Size","description":"The Guided Matrix Multiplication Illegal SLM Size\nsample demonstrates a guided approach to debugging\nincorrect usage when reserving more memory for a\nwork-group than there is space, also called...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_SLMSize","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"guided_bandwidthTest_SYCLMigration","description":"This sample shows the demonstrates how to measure\nthe memcopy bandwidth of the GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_bandwidthTest_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_concurrentKernels_SYCLMigration","description":"This sample shows the execution of Multiple\nKernels on the device at the same time.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_concurrentKernels_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_cudaOpenMP_SYCLMigration","description":"This sample demonstrates to use OpenMP API to\nwrite an application for multiple GPUs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_cudaOpenMP_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_histogram_SYCLMigration","description":"This sample implements 64-bin histogram\ncalculation of arbitrary-sized 8-bit data array.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/guided_histogram_SYCLMigrated","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_histogram_SYCLMigration","description":"This sample implements 64-bin histogram\ncalculation of arbitrary-sized 8-bit data array.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/guided_histogram_SYCLMigrated","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_inlinePtx_SYCLMigration","description":"This sample shows the demonstrates the use of SYCL\nqueues for PTX assembly on GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_inlinePtx_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_montecarloMultiGPU_SYCLMigration","description":"Evaluates fair call price for a given set of\nEuropean Options using the MonteCarlo approach","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_monteCarloMultiGPU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"guided_OceanFFT_SYCLMigration","description":"This sample shows the demonstrates the use of SYCL\nqueues for Ocean height field on GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SpectralMethods\/guided_OceanFFT_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_oceanFFT_SYCLMigration","description":"This sample shows the demonstrates the use of SYCL\nqueues for Ocean height field on GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_oceanFFT_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_radixSortThrust_SYCLMigration","description":"Radix Sort Thrust Migrated demonstrates a fast and\nefficient parallel radix sort that uses the SYCL\nversion of the THRUST library","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_radixSortThrust_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"guided_scalarProd_SYCLMigration","description":"This sample calculates scalar products of a given\nset of input vector pairs on CPU and GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_scalarProd_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_shfl_scan_SYCLMigration","description":"This sample demonstrates the migration of CUDA\nshuffle intrinsic APIs to SYCL group algorithm to\nperform a scan operation.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_shflScan_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_shfl_scan_SYCLMigration","description":"This sample demonstrates the migration of CUDA\nshuffle intrinsic APIs to SYCL group algorithm to\nperform a scan operation.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_shflScan_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"guided_simpleAtomicIntrinsics_SYCLMigration","description":"This sample demonstrates the use of various SYCL\narithmetic Atomic Intrinsic functions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_simpleAtomicIntrinsics_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"GZIP","description":"Reference design demonstrating high-performance\nGZIP compression on Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/gzip","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Hardware Reuse","description":"An Intel\u00ae FPGA tutorial that demonstrates how to\nreuse hardware in your FPGA designs by using loops\nand task sequences.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/task_sequence\/hardware_reuse","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Hidden Markov Models","description":"Hidden Markov Models using Data Parallel C++","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/hidden-markov-models","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Histogram","description":"This sample demonstrates Histogram using Dpstd\nAPIs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/histogram","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Host Pipes","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nhost pipes","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/hostpipes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Host-Device Streaming using USM","description":"An FPGA tutorial demonstrating how to stream data\nbetween the host and device with low latency and\nhigh throughput","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/simple_host_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"HSOpticalFlow","description":"Variational optical flow estimation example. Uses\ntextures for image operations. Shows how simple\nPDE solver can be accelerated with SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_HSOpticalFlow_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"HSOpticalFlow","description":"Variational optical flow estimation example. Uses\ntextures for image operations. Shows how simple\nPDE solver can be accelerated with SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/guided_HSOpticalFlow_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Intel PyTorch GPU Inference Optimization with AMP","description":"This sample illustrates how to use AMP BFLOAT16 in\nPyTorch on Intel dGPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_GPU_InferenceOptimization_with_AMP","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":["ats-m","dg2","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Intel(R) Extension for Scikit-learn: SVC for Adult dataset","description":"Use Intel(R) Extension for Scikit-learn to\naccelerate the training and prediction with SVC\nalgorithm on Adult dataset. Compare the\nperformance of SVC algorithm optimized through...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/Intel_Extension_For_SKLearn_Performance_SVC_Adult","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Distribution for Python* Distributed K- Means Model","description":"This sample code illustrates how to train and\npredict with a distributed K-Means model with the\nIntel\u00ae Distribution of Python using the Python API\npackage Daal4py powered by Intel\u00ae oneDAL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_daal4py_DistributedKMeans","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Distribution for Python* Distributed Linear regression","description":"This sample code illustrates how to train and\npredict with a Distributed Linear Regression model\nwith the Intel\u00ae Distribution of Python using the\nPython API package Daal4py powered by Intel\u00ae...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_daal4py_DistributedLinearRegression","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Distribution for Python* programming language Daal4py Getting Started","description":"This sample illustrates how to do Batch Linear\nRegression using the Python API package Daal4py\npowered by Intel\u00ae oneDAL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelPython_daal4py_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Extension for PyTorch* Getting Started","description":"This sample illustrates how to train a PyTorch\nmodel and run inference with Intel\u00ae Extension for\nPyTorch*","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_PyTorch_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["ats-m","pvc"],"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Extension for PyTorch* Training Optimizations for Bfloat16","description":"This sample illustrates how to train a PyTorch\nmodel using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_TrainingOptimizations_AMX_BF16","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"Intel\u00ae Extension for Scikit-learn* Getting started","description":"This sample illustrates how to do Image\nclassification using SVM classifier from Python\nAPI package SKlearnex with the use of Intel\u00ae\noneAPI Data Analytics Library (oneDAL).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_SKLearn_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Extension for TensorFlow* BF16 Inference","description":"This sample illustrates how to inference a\nTensorFlow model using Advanced Matrix Extensions\nBfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Inference","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"Intel\u00ae Extension for TensorFlow* Getting Started","description":"This code sample will guide users how to run a\nTensorFlow inference workload on both the GPU and\nCPU by using the Intel\u00ae AI Analytics Toolkit.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_TensorFlow_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["ats-m","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Neural Compressor Accelerate Inference with Intel\u00ae Optimization for TensorFlow*","description":"This sample illustrates how to run Intel\u00ae Neural\nCompressor to quantize the FP32 model trained by\nKeras on Tensorflow to INT8 model to speed up the\ninference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Sample-for-Tensorflow","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Optimization for TensorFlow* Getting Started","description":"This sample illustrates how to train a TensorFlow\nmodel and run inference with oneMKL and oneDNN.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelTensorFlow_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Optimization for TensorFlow* pre-trained model for inference","description":"This tutorial will guide you how to optimize a\npre-trained model for a better inference\nperformance, and also analyze the model pb files\nbefore and after the inference optimizations.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_InferenceOptimization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Optimization for XGBoost* Getting Started","description":"The sample illustrates how to setup and train an\nXGBoost model on datasets for prediction","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelPython_XGBoost_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Python NumPy vs Numba_dpex","description":"This sample shows how to achieve the same accuracy\nof the k-NN model classification while using\nnumpy, numba and numba_dpex.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_Numpy_Numba_dpex_kNN","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Python XGBoost Daal4py Prediction","description":"This sample code illustrates how to analyze the\nperformance benefit of minimal code changes to\nport pre-trained XGBoost model to daal4py\nprediction for much faster prediction","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_XGBoost_daal4pyPrediction","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Intel\u00ae Python XGBoost Performance","description":"This sample code illustrates how to analyze the\nperformance benefit from using Intel training\noptimizations upstreamed by Intel to latest\nXGBoost compared to un-optimized XGBoost 0.81","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPython_XGBoost_Performance","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Interactive chat based on DialoGPT model using Intel\u00ae Extension for PyTorch* Quantization","description":"This sample demonstrates how to create interactive\nchat based on pre-trained DialoGPT model and add\nthe Intel\u00ae Extension for PyTorch* quantization to\nit.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPytorch_Interactive_Chat_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Intrinsics","description":"Demonstrates the Intrinsic functions of the Intel\u00ae\noneAPI C++ Compiler Classic","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/Intrinsics","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Introduction to Machine Learning","description":"The Jupyter Notebooks in these samples are\nintended to give professors and students an\naccessible but challenging introduction to machine\nlearning. It enumerates and describes many...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Introduction_to_Machine_Learning","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Invocation Interfaces","description":"An Intel\u00ae FPGA tutorial that demonstrates the\ndifferences between a streaming invocation\ninterface and a register-mapped invocation\ninterface on an IP component","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/hls_flow_interfaces\/invocation_interfaces","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"IO streaming with SYCL IO pipes","description":"An FPGA tutorial describing how to stream data to\nand from SYCL IO pipes.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/io_streaming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"ISO2DFD DPCPP","description":"The ISO2DFD sample illustrates SYCL Basics using\n2D Finite Difference Wave Propagation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso2dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"ISO3DFD","description":"The ISO3DFD Sample illustrates SYCL using Finite\nDifference Stencil Kernel for solving 3D Acoustic\nIsotropic Wave Equation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso3dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"ISO3DFD OMP Offload","description":"A Finite Difference Stencil Kernel for solving 3D\nAcoustic Isotropic Wave Equation using OpenMP*\n(OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/StructuredGrids\/iso3dfd_omp_offload","languages":[{"cpp":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Jacobi","description":"A small SYCL (C++) example which solves a harcoded\nlinear system with Jacobi iteration. The sample\nincludes two versions of the same program: with\nand without bugs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/jacobi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Jacobi Cuda Graphs","description":"Migration of JacobiCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\ninplace of CUDA Graph API's and optimization of\nthe migrated code","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_jacobiCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Jacobi Cuda Graphs","description":"Migration of JacobiCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\ninplace of CUDA Graph API's and optimization of\nthe migrated code","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_jacobiCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Jacobi Iterative Solver","description":"Jacobi Iterative Solver provides step by step\ninstructions for CPU, GPU and multiple GPU offload","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_jacobi_iterative_gpu_optimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Kernel Args Restrict","description":"Explain the kernel_args_restrict attribute and its\neffect on the performance of Intel\u00ae FPGA kernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/kernel_args_restrict","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Latency Control","description":"An Intel\u00ae FPGA tutorial demonstrating the Latency\ncontrol feature","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/experimental\/latency_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Leveraging Intel Extension for TensorFlow with LSTM for Text Generation","description":"This sample demonstrates how to train your model\nwith LSTM (Long short-term memory) faster by using\nIntel Extension for TensorFlow's LSTM training\nlayer on Intel platform","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_TextGeneration_with_LSTM","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Lidar Object Detection using PointPillars","description":"Object detection using a LIDAR point cloud as\ninput. This implementation is based on the paper\n'PointPillars: Fast Encoders for Object Detection\nfrom Point Clouds'","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/LidarObjectDetection-PointPillars","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Loop Coalesce","description":"An Intel\u00ae FPGA tutorial demonstrating the\nloop_coalesce attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_coalesce","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Loop Fusion","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nthe loop_fusion attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_fusion","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Loop Initiation Interval","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nthe initiation_interval attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_initiation_interval","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Loop IVDEP","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nthe loop_ivdep attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_ivdep","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Loop Unroll","description":"An Intel\u00ae FPGA tutorial design demonstrating the\nloop_unroll attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_unroll","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Loop Unroll","description":"Demonstrates the use of loop unrolling as a simple\noptimization technique to speed up compute and\nincrease memory access throughput.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/loop_unroll","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"LSU Control","description":"An Intel\u00ae FPGA tutorial demonstrating how to\nconfigure the load-store units (LSU) in a SYCL\nprogram using the LSU controls extension","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/lsu_control","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Mandelbrot","description":"The visualization of Mandelbrot Set - a fractal\nexample in mathematics","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/mandelbrot","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Mandelbrot","description":"The Mandelbrot Set - a fractal\u00a0example\nin\u00a0mathematics","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/mandelbrot","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Mandelbrot OMP","description":"Calculates the Mandelbrot Set and outputs a BMP\nimage representation using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CombinationalLogic\/MandelbrotOMP","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiplication cuBLAS Migrated","description":"This sample shows the migration of a more complex\nmatrix multiplication sample from cuBLAS to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_matrix_mul_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply","description":"Reference design demonstrating high-performance\ngeneral matrix multiplication on an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/matmul","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply","description":"This sample Multiplies two large Matrices in\nparallel using SYCL and OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/matmul","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply","description":"Demonstrates how compiler auto-vectorization can\nimprove the performance of a program. The\noptimization report option is used to identify\npotential points of performance improvement.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/matmul","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply Advisor","description":"Simple program that shows how to improve the\nIntel&reg; oneAPI Data Parallel C++ (DPC++) Matrix\nMultiplication program using Intel&reg;\nVTune&trade; Profiler and Intel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Advisor\/matrix_multiply_advisor","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply Fortran","description":"Demonstrates how to use OpenMP* directives with\nFortran to offload computations to an Intel GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_matrix_mul_OpenMP","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply MKL","description":"Accelerate Matrix Multiplication with Intel\u00ae\noneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/matrix_mul_mkl","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply VTune\u2122 Profiler","description":"Simple program that shows how to improve the Data\nParallel C++ (DPC++) Matrix Multiplication program\nusing Intel&reg; VTune&trade; Profiler and\nIntel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_vtune","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Matrix Multiply VTune\u2122 Profiler - C","description":"Simple program that shows how to improve the C\nlanguage (CPU only) Matrix Multiplication program\nusing Intel&reg; VTune&trade; Profiler and\nIntel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_c","languages":[{"c":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Max Interleaving","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nthe loop max_interleaving attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/max_interleaving","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Max Reinvocation Delay","description":"An Intel\u00ae FPGA tutorial demonstrating the usage of\nthe loop max_reinvocation_delay attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/max_reinvocation_delay","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Maxloc Reductions in oneAPI","description":"Perform maxloc reductions with oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/maxloc_reductions","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Mem Channels","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe mem_channel buffer property and the -Xsno-\ninterleaving flag","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/mem_channel","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Memory Attributes","description":"An Intel\u00ae FPGA tutorial demonstrating the use of\non-chip memory attributes to control memory\nstructures in a SYCL program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/memory_attributes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Merge Sort","description":"A Reference design demonstrating merge sort on an\nIntel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/merge_sort","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Merge SPMV","description":"The Sparse Matrix Vector sample provides a\nparallel implementation of a Merge based Sparse\nMatrix and Vector Multiplication Algorithm using\nSYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SparseLinearAlgebra\/merge-spmv","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"MergeSort OMP","description":"Classic OpenMP* (OMP) Mergesort algorithm","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/GraphTraversal\/MergesortOMP","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Model Zoo for Intel\u00ae Architecture Inference With FP32 Int8","description":"This code example illustrates how to run FP32 and\nInt8 inference on Resnet50 with TensorFlow using\nIntel\u00ae Model Zoo","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Modin* Getting Started","description":"This sample illustrates how to use Modin*\naccelerated Pandas functions and notes the\nperformance gain when compared to standard Pandas\nfunctions","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Modin_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Modin* Vs. Pandas Performance","description":"This sample code illustrates how Modin*\naccelerates the performance of Pandas for\ncomputational operations on a dataframe.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Modin_Vs_Pandas","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Monte Carlo European Opt","description":"Monte Carlo Simulation of European Options pricing\nwith Intel\u00ae oneMKL random number generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/monte_carlo_european_opt","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Monte Carlo Pi","description":"Estimating Pi with Intel\u00ae oneMKL random number\ngenerators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/monte_carlo_pi","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Monte Carlo Pi","description":"Monte Carlo procedure for estimating Pi","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/monte_carlo_pi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"MontecarloMultiGPU","description":"Evaluates fair call price for a given set of\nEuropean Options using the MonteCarlo approach","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/guided_MonteCarloMultiGPU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"MPI Communications Using GPU Buffers","description":"Sample to demonstrate basic MPI communications\nusing GPU buffers.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/MPI\/mpi_send_gpu","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"MVDR Beamforming","description":"A reference design demonstrating a high-\nperformance streaming MVDR beamformer","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/mvdr_beamforming","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"N-Body","description":"An N-Body simulation is a simulation of a\ndynamical system of particles, usually under the\ninfluence of physical forces, such as gravity.\nThis N-Body sample code is implemented using...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/N-BodyMethods\/Nbody","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"N-Way Buffering","description":"Intel\u00ae FPGA tutorial design to demonstrate\noverlapping kernel execution with buffer transfers\nand multi-threaded host-processing to improve\nsystem performance","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/n_way_buffering","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Nios V","description":"Simulate a system with an FPGA IP produced with\nthe Intel\u00ae oneAPI DPC++\/C++ Compiler, and a Nios\u00ae\nV softcore processor.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/niosv","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Nstreams Device Selection","description":"The Nstreams Device Selection sample demonstrates\nhow to use the Intel\u00ae oneAPI Base Toolkit (Base\nKit) and Intel\u00ae oneAPI DPC++ Library (oneDPL)\nfound in the Base Kit to apply device selection...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/dynamic_selection\/nstream","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Numba Data Parallel Python* Essentials Training","description":"Numba Data Parallel Python* Essentials Tutorials\nusing Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Numba_dpex_Essentials_training","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"Odd Even Merge Sort","description":"This is the preferred algorithm of choice for\nsorting batches of short-sized to mid-sized (key,\nvalue) array pairs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_oddEvenMergeSort_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Odd Even Merge Sort","description":"This is the preferred algorithm of choice for\nsorting batches of short-sized to mid-sized (key,\nvalue) array pairs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_oddEvenMergeSort_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"On-Chip Memory Cache","description":"Intel\u00ae FPGA tutorial demonstrating the caching of\non-chip memory to reduce loop initiation interval","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/onchip_memory_cache","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"oneCCL Getting Started","description":"Basic Intel\u00ae oneCCL programming model for both\nIntel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneCCL\/oneCCL_Getting_Started","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"OpenMP Offload","description":"Demonstration of the new OpenMP offload features\nsupported by the Intel(r) oneAPI DPC++\/C++\nCompiler","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/OpenMP_Offload_Features","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"OpenMP Offload C++ Tutorials","description":"C++ OpenMP Offload Basics using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/Jupyter\/OpenMP-offload-training","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"OpenMP Offload Fortran Tutorials","description":"Fortran OpenMP Offload Basics using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/Jupyter\/OpenMP-offload-training","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"OpenMP* Primes","description":"Fortran Tutorial - Using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/CombinationalLogic\/openmp-primes","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"OpenMP* Reduction","description":"This sample models OpenMP* (OMP) Reduction in\ndifferent ways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/ParallelPatterns\/openmp_reduction","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Optimization Targets","description":"An Intel\u00ae FPGA tutorial demonstrating setting\noptimization targets","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/optimization_targets","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Optimize Inner Loop","description":"An Intel\u00ae FPGA tutorial design demonstrating how\nto optimize the throughput of inner loops with low\ntrip counts","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/optimize_inner_loop","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Optimize Integral","description":"Fortran Sample - Simple Compiler Optimizations","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/optimize-integral","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Optimize PyTorch Models using Intel\u00ae Extension for PyTorch* (IPEX)","description":"Applying IPEX Optimizations to a PyTorch workload\nin a step-by-step manner to gain performance\nboost.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_Extensions_Inference_Optimization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Optimize PyTorch Models using Intel\u00ae Extension for PyTorch* (IPEX) Quantization","description":"Applying IPEX Quantization Optimizations to a\nPyTorch workload in a step-by-step manner to gain\nperformance boost in inference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPytorch_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Particle Diffusion","description":"The Particle Diffusion code sample illustrates\nSYCL using a simple (non-optimized) implementation\nof a Monte Carlo Simulation of the Diffusion of\nWater Molecules in Tissue","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/particle-diffusion","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"PCA","description":"Reference design implementing the Principle\nComponent Analysis (PCA) of matrices on Intel\u00ae\nFPGAs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/pca","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Pipe Array","description":"An Intel\u00ae FPGA tutorial showcasing a design\npattern to enables the creation of arrays of pipes","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/pipe_array","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Pipes","description":"How to use Pipes to transfer data between kernels\non an Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/pipes","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Platform Designer - Intel\u00ae Arria\u00ae 10 SX SoC Developer Kit","description":"An Intel\u00ae FPGA tutorial demonstrating how to\nexport a reusable IP component to Intel\u00ae Quartus\u00ae\nPrime Pro and Platform Designer.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/platform_designer","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Predictive Modeling with XGBoost* and the Intel\u00ae AI Analytics Toolkit (AI Kit)","description":"Predictive Modeling using Decision Trees, Bagging,\nand XGBoost using Intel\u00ae AI Analytics Toolkit and\nJupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Predictive_Modeling_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Prefix Sum","description":"Compute Prefix Sum using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/PrefixSum","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Printf","description":"This FPGA tutorial explains how to use the\nprintf() to print in a SYCL FPGA program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/printf","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"private_copies","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe private_copies attribute to trade off the\nresource use and the throughput of a SYCL FPGA\nprogram","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/private_copies","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"PyTorch Inference Optimizations with Advanced Matrix Extensions Bfloat16 and Integer8","description":"This sample illustrates how to do inference with a\nPyTorch model using Advanced Matrix Extensions\nBfloat16 and Integer8","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_InferenceOptimizations_AMX_BF16_INT8","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"QRD","description":"Reference design demonstrating high-performance QR\nDecomposition (QRD) of real and complex matrices\non a Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/qrd","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"QRI","description":"Reference design demonstrating high-performance\nQR-based matrix inversion (QRI) of real and\ncomplex matrices on a Intel\u00ae FPGA","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/qri","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Quantize Transformer Models using Intel\u00ae Extension for Transformers* (ITREX)","description":"Quantizing Transformer models in a step-by-step\nmanner to enable memory efficient LLM inference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTransformers_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"quasirandomGenerator","description":"Implements Niederreiter Quasirandom Sequence\nGenerator and Inverse Cumulative Normal\nDistribution functions for the generation of\nStandard Normal Distributions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_quasirandomGenerator_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"quasirandomGenerator","description":"Implements Niederreiter Quasirandom Sequence\nGenerator and Inverse Cumulative Normal\nDistribution functions for the generation of\nStandard Normal Distributions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_quasirandomGenerator_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Radix Sort Thrust Migrated","description":"Radix Sort Thrust Migrated demonstrates a fast and\nefficient parallel radix sort that uses the SYCL\nversion of the THRUST library","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/radix_sort_thrust_migrated","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Random Sampling Without Replacement","description":"Multiple simple random sampling without\nreplacement with Intel\u00ae oneMKL random number\ngenerators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/random_sampling_without_replacement","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Read-Only Cache","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe read-only cache feature to boost the\nthroughput of a SYCL FPGA program","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/read_only_cache","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Remove Loop Carried Dependency","description":"An Intel\u00ae FPGA tutorial design demonstrating\nperformance optimization by removing loop carried\ndependencies","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/loop_carried_dependency","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Rodinia NW DPCT","description":"Migrate a CUDA project using the Intel\u00ae DPCT\nintercept-build feature to create a compilation\ndatabase. The compilation database provides\ncompilation options, settings, macro...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/rodinia-nw-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Run distributed deep learning workloads with Intel\u00ae Optimization for Horovod","description":"This sample demonstrates how to run multi-card\ninference and training on Intel GPUs using Intel\nOptimization for Horovod and TensorFlow","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Horovod_Distributed_Deep_Learning","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"ScalarProd Sample","description":"This sample calculates scalar products of a given\nset of input vector pairs on CPU and GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_scalarProd_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Scheduler Target FMAX","description":"Explain the scheduler_target_fmax_mhz attribute\nand its effect on the performance of Intel\u00ae FPGA\nkernels","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/scheduler_target_fmax","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"segmentationTreeThrust","description":"Demonstrates an approach to the image segmentation\ntrees construction.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_segmentationTree_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Sepia Filter","description":"A program that converts an image to Sepia Tone","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/sepia-filter","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Sepia Filter Dynamic Device Selection","description":"The sample demonstrates how to use the Intel\u00ae\noneAPI Base Toolkit (Base Kit) and Intel\u00ae oneAPI\nDPC++ Library (oneDPL) found in the Base Kit to\neasily apply Dynamic Device Selection policies...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/dynamic_selection\/sepia-filter-ds","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Shannonization","description":"An Intel\u00ae FPGA tutorial design that demonstrates\nan optimization for removing computation from the\ncritical path and improves Fmax\/II","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/shannonization","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Simple Add","description":"This simple sample adds two large vectors in\nparallel and provides a \u2018Hello World!\u2019 like sample\nto ensure your environment is setup correctly\nusing C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/simple-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU","FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Simple Cuda Graphs Sample","description":"Migration of simpleCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\nand SYCL Graph extension in place of CUDA Graph\nAPIs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_simpleCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concept and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Simple Cuda Graphs Sample","description":"Migration of simpleCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\nand SYCL Graph extension in place of CUDA Graph\nAPIs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_simpleCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concept and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"simpleCUBLAS_LU","description":"This sample implements LU decomposition factors a\nmatrix as the product of an upper triangular\nmatrix and lower triangular matrix.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_simpleCUBLAS_LU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"simpleCUBLAS_LU","description":"This sample implements LU decomposition factors a\nmatrix as the product of an upper triangular\nmatrix and lower triangular matrix.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_simpleCUBLAS_LU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Sobel Edge Detection","description":"Offload Fortran loops to a GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/EdgeDetection\/sobel-edge-detection","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Sparse Conjugate Gradient","description":"Solve Sparse linear systems with the Conjugate\nGradient method using Intel\u00ae oneMKL sparse BLAS","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/sparse_conjugate_gradient","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Speculated Iterations","description":"An Intel\u00ae FPGA tutorial demonstrating the\nspeculated_iterations attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/speculated_iterations","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Stable Sort By Key","description":"This sample models Stable Sort By Key during the\nsorting of 2 sequences (keys and values) only keys\nare compared but both keys and values are swapped","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDPL\/stable_sort_by_key","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Stall Enable","description":"An Intel\u00ae FPGA tutorial demonstrating the\nuse_stall_enable_clusters attribute","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/stall_enable","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"STREAM","description":"The STREAM is a program that measures memory\ntransfer rates in MB\/s for simple computational\nkernels coded in C","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Benchmarks\/STREAM","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Streaming Data Interfaces","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\npipes to implement streaming interfaces on IP\nComponents","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/hls_flow_interfaces\/streaming_data_interfaces","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Streaming Video - 2D Convolution","description":"Reference design demonstrating a 2D convolution IP\ncomponent that can be exported to Intel\u00ae Quartus\u00ae\nPrime","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/ReferenceDesigns\/convolution2d","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Reference Designs and End to End","altindex":null,"cpuInstructionSets":null},{"name":"Student's T-test","description":"Performing Student's T-test with Intel\u00ae oneMKL\nVector Statistics functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/student_t_test","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"SYCL Essentials Tutorials","description":"SYCL Essentials Tutorials using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/oneapi-essentials-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"SYCL OpenCL Interoperability Samples","description":"Samples showing SYCL and OpenCL Interoperability","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/OpenCLInterop","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"SYCL Performance Portability","description":"SYCL Performance Portability using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/sycl-performance-portability-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","altindex":null,"cpuInstructionSets":null},{"name":"System Profiling","description":"An Intel\u00ae FPGA tutorial demonstrating how to use\nthe OpenCL* Intercept Layer to improve a design\nwith the double buffering optimization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/system_profiling","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"tachyon","description":"Simple ray tracer demonstrating the use of\nIntel&reg; oneTBB and OpenMP along with\noptimizations based on Intel VTune&trade; Profiler\nresults.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/tachyon","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":1.0,"cpuInstructionSets":null},{"name":"Task Sequences Parallel Loops","description":"An Intel\u00ae FPGA tutorial that demonstrates how to\nuse task sequences to describe multiple parallel\nloops in a single kernel","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Features\/task_sequence\/parallel_loops","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"TBB ASYNC SYCL","description":"This sample illustrates how computational kernel\ncan be split for execution between CPU and GPU\nusing Intel\u00ae oneTBB Flow Graph asynchronous node\nand functional node. The Flow Graph...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-async-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"TBB Resumable Tasks SYCL","description":"This sample illustrates how computational kernel\ncan be split for execution between CPU and GPU\nusing Intel\u00ae oneTBB Resumable Task and\nparallel_for. The Intel\u00ae oneTBB resumable task...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-resumable-tasks-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"TBB Task SYCL","description":"This sample illustrates how 2 Intel\u00ae oneTBB tasks\ncan execute similar computational kernels with one\ntask executing SYCL code and another one executing\nthe Intel\u00ae oneTBB code. This TBB Task SYCL...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneTBB\/tbb-task-sycl","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"TensorFlow Fine-tuning and Inference for LLMs with Bfloat16","description":"This sample illustrates how to fine-tune and do\ninference of a TensorFlow LLM model using Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_for_LLMs","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"TensorFlow Training Optimizations with Advanced Matrix Extensions Bfloat16","description":"This sample illustrates how to train a TensorFlow\nmodel using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"TensorFlow Transformer with Advanced Matrix Extensions bfloat16 Mixed Precision Learning","description":"This sample code demonstrates optimizing a\nTensorFlow model with Intel\u00ae Advanced Matrix\nExtensions (Intel\u00ae AMX) using bfloat16 (Brain\nFloating Point) on Sapphire Rapids","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Transformer_AMX_bfloat16_MixedPrecision","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":["AVX512","AMX"]},{"name":"threadFenceReduction","description":"Implements a reduction operation on an array of\nvalues using the sycl::atomic_fence function to\nproduce a single value in a single kernel.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_threadFenceReduction_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Triangular Loop","description":"An Intel\u00ae FPGA tutorial demonstrating an advanced\noptimization technique for triangular loops","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/triangular_loop","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null},{"name":"Use Library","description":"An Intel\u00ae FPGA Tutorial demonstrating how to\ncreate Intel\u00ae FPGA libraries and to incorporate\nthem in a Intel\u00ae oneAPI SYCL project","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/Tools\/use_library","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Vector Add DPCT","description":"Simple project to illustrate the basic migration\nof CUDA code. Use this sample to ensure your\nenvironment is configured correctly and to\nunderstand the basics of migrating existing...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Migration\/vector-add-dpct","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","altindex":null,"cpuInstructionSets":null},{"name":"Vectorize VecMatMult","description":"Fortran Tutorial - Using Auto Vectorization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/vectorize-vecmatmult","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","altindex":null,"cpuInstructionSets":null},{"name":"Zero Copy Data Transfer","description":"An Intel\u00ae FPGA tutorial demonstrating zero-copy\nhost memory using the SYCL restricted Unified\nShared Memory (USM) model","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL_FPGA\/Tutorials\/DesignPatterns\/zero_copy_data_transfer","languages":[{"cpp":{}}],"targetDevice":["FPGA"],"gpuRequired":null,"expertise":"Code Optimization","altindex":null,"cpuInstructionSets":null}]